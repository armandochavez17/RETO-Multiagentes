# -*- coding: utf-8 -*-
"""Avance2_Reto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fX0sS6az6HTV6jtNZy0JN64XKyZjCXLy
"""

!pip install agentpy
# Model design
import agentpy as ap
import numpy as np, random

# Visualization
import matplotlib.pyplot as plt
import IPython

import agentpy as ap
import numpy as np
import random

class enviroment(ap.Grid):
    """Grid urbano con casas y calles basado en la rotonda de las casas."""

    def setup(self):
        # Tamaño de la rotonda
        self.shape = (16, 16)
        # Matriz: 1=calle, 0=casa
        self.mapa = np.zeros(self.shape, dtype=int)

        # 1. Avenida perimetral
        self.mapa[0, :] = 1
        self.mapa[-1, :] = 1
        self.mapa[:, 0] = 1
        self.mapa[:, -1] = 1

        # 2. Calle horizontal central
        fila_central = 5
        #self.mapa[fila_central, 2:-2] = 1
        self.mapa[1:15, fila_central] = 1
        # 3. Tres calles verticales cortas, conectadas a la horizontal
        for fila in [5, 8, 11]:
            self.mapa[fila, fila_central:13] = 1  # Desde arriba hasta la calle horizontal

        # 4. Conexion con la parte de afuera
        self.mapa[5, 15] = 1  # Conecta la calle horizontal superior con la avenida derecha
        self.mapa[8, 15] = 1  # Calle media con la avenida derecha
        self.mapa[11, 15] = 1 # Calle inferior con la avenida derecha

        self.mapa[5, 0] = 1   # Conecta la calle horizontal superior con la avenida izquierda
        self.mapa[8, 0] = 1   # Calle media con la avenida izquierda
        self.mapa[11, 0] = 1  # Calle inferior con la avenida izquierda

        # Sets de calles y casas
        self.casas = np.where(self.mapa == 0)
        self.calles = np.where(self.mapa == 1)
        self.casas_set = set(zip(*self.casas))
        self.calles_set = set(zip(*self.calles))
        self.salida = (0, fila_central)  # Por ejemplo, salida sobre la avenida superior

    def es_calle(self, pos):
        """Devuelve True si la celda es calle."""
        return tuple(pos) in self.calles_set

    def es_casa(self, pos):
        return tuple(pos) in self.casas_set

class Vehiculo(ap.Agent):
    """Agente que simula un vehiculo en la rotonda."""

    def setup(self):
        self.rotonda = self.model.enviroment
        # Velocidad inicial aleatoria (horiz o vert, sentido positivo)
        self.velocity = np.array(random.choice([[1,0], [0,1], [-1,0], [0,-1]]))
        self.energia = 10  # Opcional
    #Se obtiene las posicion
    def get_position(self):
        return self.rotonda.positions[self]

    def mover(self):
        """Mueve el agente si la celda destino es calle, si no busca alternativa."""
        pos_actual = self.get_position()
        pos_siguiente = tuple(np.array(pos_actual) + self.velocity)

        # Si la siguiente celda es calle, avanza
        if self.rotonda.es_calle(pos_siguiente):
            self.rotonda.move_by(self, self.velocity)
            self.energia -= 1
        else:
            # Si no puede avanzar, prueba girar (izq o der)
            alternativas = [
                np.array([self.velocity[1], -self.velocity[0]]),   # izquierda
                np.array([-self.velocity[1], self.velocity[0]])    # derecha
            ]
            random.shuffle(alternativas)
            movido = False
            for alt in alternativas:
                nueva_pos = tuple(np.array(pos_actual) + alt)
                if self.rotonda.es_calle(nueva_pos):
                    self.velocity = alt
                    self.rotonda.move_by(self, self.velocity)
                    self.energia -= 1
                    movido = True
                    break
            if not movido:
                # Si no puede moverse, se queda y gasta menos energía
                self.energia -= 0.5

    def update(self):
        self.mover()

class UrbanModel(ap.Model):
    def setup(self):
        self.enviroment = enviroment(self, shape=(16,16))
        # Ubicación inicial aleatoria en una calle
        calles_list = list(self.enviroment.calles_set)
        start = random.choice(calles_list)
        self.vehiculos = ap.AgentList(self, 1, Vehiculo)
        self.enviroment.add_agents(self.vehiculos, positions=[start])

    def step(self):
        self.vehiculos.update()

"""Visualizacion"""

def animation_plot_single(m, ax):
    ax.set_title(f"Step t={m.t}")

    # Pintar el mapa: calles (1) y casas (0)
    mapa = m.enviroment.mapa
    ax.imshow(mapa.T, origin='lower', cmap='Greys', alpha=0.3)  # Trasponer para que cuadre con scatter

    # Pintar los vehiculos
    posiciones = np.array([a.get_position() for a in m.vehiculos])
    if len(posiciones) > 0:
        xs, ys = posiciones.T
        # Diferenciar por dirección del vehiculo
        for v in m.vehiculos:
            x, y = v.get_position()
            if (v.velocity == [1,0]).all():
                marker = '>'
            elif (v.velocity == [-1,0]).all():
                marker = '<'
            elif (v.velocity == [0,1]).all():
                marker = '^'
            elif (v.velocity == [0,-1]).all():
                marker = 'v'
            else:
                marker = 'o'
            ax.scatter(x, y, s=80, c='red', marker=marker)

    # Ajustar límites y estética
    ax.set_xlim(-0.5, m.enviroment.shape[0]-0.5)
    ax.set_ylim(-0.5, m.enviroment.shape[1]-0.5)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal')

def animation_plot(m, p):
    fig = plt.figure(figsize=(7,7))
    ax = fig.add_subplot(111)
    animation = ap.animate(m(p), fig, ax, animation_plot_single)
    return IPython.display.HTML(animation.to_jshtml(fps=5))

parameters = {
    'size': 20,     # Tamaño del grid
    'steps': 100,   # Número de pasos de la simulación
}

animation_plot(UrbanModel, parameters)